<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <script src="https://www.w3.org/Tools/respec/respec-w3c" async class="remove"></script>
    <title>Live Protocol Handler Requirements</title>
    <style>
      body {
        background: url(proposal.svg) no-repeat fixed !important;
        background-size: 25px 380px !important;
      }
    </style>
    <script class="remove">
      var respecConfig = {
        specStatus: 'unofficial',
        postProcess: [(config, doc) => {
          let time = doc.querySelector('#w3c-state time')
            , h2 = doc.querySelector('#w3c-state')
          ;
          h2.innerHTML = 'Proposal ';
          h2.appendChild(time);
        }],
        editors: [{
          name: 'Robin Berjon',
          company: 'Protocol Labs',
          url: 'https://berjon.com/',
        }],
        github: {
          repoURL: 'https://github.com/darobin/proto-handler-reqs',
          branch: 'main',
        },
        edDraftURI: 'https://darobin.github.io/proto-handler-reqs/',
        shortName: 'proto-handler-reqs',
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document captures requirements to evolve protocol handlers as available on the web. The goal is to
        make it possible to extend the set of protocols that are supported while maintaining a high level of
        security and trust for users.
      </p>
    </section>
    <section id="sotd"></section>
    <section>
      <h2>Handlers Beyond Handoff</h2>
      <p>
        Protocol handlers today are focused on single-shot handoff. When activating a <code>mailto:</code> link,
        the browser will either hand it off to the OS for a native application to handle, or will pass it to a
        (top-level) URL that will receive it as a parameter and process it. In either case, the interaction
        is not incorporated into the current context and no further interaction with the protocol is possible.
        In effect, this is more a scheme dispatcher than a comprehensive handler for a given protocol.
      </p>
      <p>
        Today's on-ramp for new protocols to become used on the web beyond a simple handoff however is too steep.
        While there is <a href="https://github.com/whatwg/html/issues/9158">interest from implementers in loosening
        handler registration</a>, that does not extend to the ability to fully integrate new protocols into the
        web stack such that they can be the source of top-level documents, iframes, fetch, images, etc.
      </p>
      <p>
        This document captures requirements for browser extensions to be able to register as full-fledged (or
        at least <em>fuller</em>-fledged) programmatic protocol handlers. For instance, using this approach an
        extension could implement support for IPFS directly within any browser context.
      </p>
    </section>
    <section>
      <h2>Integration</h2>
      <p>
        One goal is that registering a protocol handler in different ways and at different levels should map to
        a unified underlying model to the extent possible, so as to ensure that a single code path controls
        protocol handling.
      </p>
      <p>
        With progress towards a IANA+blocklist approach as advocated in <a href="https://github.com/whatwg/html/issues/9158">whatwg/html#9158</a>,
        there is no need to limit registration to <code>web+</code>- or <code>ext+</code>-prefixed schemes.
      </p>
      <p>
        The proposed integration method for new protocol handling is to operate a Service Worker for that
        protocol that can respond to <code>FetchEvent</code>s. The assumption is that the browser will
        address any and all schemes with HTTP semantics, and it is up to the handler to figure out the
        appropriate mapping, knowing that there will likely be impendance mismatch.
      </p>
    </section>
    <!--
      - as per lidel
     -->
    <section>
      <h2>Notes from meeting/Dietrich</h2>
      <pre>
        - https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/protocol_handlers
        - lidel: +1, reuse 'manifest.json/protocol_handlers' but instead `uriTemplate` have `serviceworkert`
          and path to .js like we have in https://developer.mozilla.org/en-US/docs/Web/Manifest (PWA manifest)
        - lidel: +1,  Web Apps  have  https://developer.mozilla.org/en-US/docs/Web/Manifest/protocol_handlers
          so maybe propose against that and say "webextensions should be the same"
        - lidel: hm.. https://w3c.github.io/manifest/ ?
    </section>
    <section>
      <h2>Integration Considerations</h2>
      <p>
        In order to plug a protocol as an extension to the browser's capabilities, we need to address more than
        simply handing a URL off to an API that returns a stream. While it is possible to expose the many
        options involved through an API, it is easy enough to shoot yourself in the foot and has enough potential
        security issues that our preference goes to selecting a strict default behavior instead.
      </p>
      <section>
        <h2>Origins</h2>
        <p>
          In order to integrate into the stack, a new scheme needs to map its URL-space onto origins. However,
          not all schemes have <code>host</code> and <code>port</code> components.
        </p>
        <p>
          <strong>Proposal</strong>. URLs are parsed as per [[url]]. Because the browser cannot guess the default
          port for that scheme, the API is expected to provide it, if it is meaningful.
        </p>
      </section>
      <section>
        <h2>Writability</h2>
        <p>
          Many protocols aren't just read-only but also allow for writing. The browser needs to know what to do
          to handle [[fetch]] verbs beyond <code>GET</code> and <code>HEAD</code> as well as <code>form</code>
          submissions.
        </p>
        <p>
          <strong>Proposal</strong>. One simpler option is to start with read-only; anything else produces a 405
          error. A writable iteration could involve using <code>FetchEvent</code> to process arbitrary HTTP requests
          and gateway them to the underlying protocol. Alternatively, we may go straight to the latter if there is
          no specific concern with the approach.
        </p>
      </section>

    </section>
    <!--
     -->
  </body>
</html>
